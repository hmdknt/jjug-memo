# Spring BootのWebアプリケーションをDockerに載せてAWS ECSで動かしている話

## メモ
### システム構成
- サービスの前提
  - 企業向けサービス
  - アクセス頻度は高くない

- EC2のものはCodeDeploy
- Docker ImageはGitLabCIでAWS ECRにデプロイ

- コンテナ化
  - したもの
    - ほぼ全ての機能(AvailabityZoneA と AvailabityZoneC)
  - しなかったもの
    - 他ファイルシステムのボリュームをマウントしたり、バッチやwebアプリが協働して動くもの
  
- WebサーバとUIコンテナ
  - ALB -> WebServer -> UIコンテナ
    - １コンテナ1プロセスを守った

### 開発環境とビルド・デプロイ
- 準備
  - PC
    - メモリ16GB~
  - Git
    - 一番早いのはコマンド:

- マージリクエスト
  - 自分のローカルの環境でリモートと同じ環境で動かせる（Dockerの良いところ）
  - 担当者以外が保守できるかを最重視
  - マージ前の動作確認はできていない

- マージ後
  - jarビルド
  - Dockerイメージビルド
  - ECR登録(docker push)
  - ECRのサービス更新(ecr-deploy)

- バージョンアップ 
  - インスタンス数 > タスク数

  - インスタンス数 = タスク数
    - 片方をDraining

  - drainingにかかる時間 
    - ターゲットグループの属性「登録解除の遅延」で指定
    - 新しいタスクをデプロイすると、すぐには置き替わらず、ここで指定した時間が経過するまで待たされる
    - タスクタイムアウトを長くすれば、処理が落ちる可能性は下がるが、デプロイ時間が伸びる可能性がある

### β環境
- 環境
  - β環境1

  - β環境2
    - 第３者環境(QA環境)
  - β環境3
    - 性能評価を行う環境
      - 性能環境だけ本番環境と同じにした
  - 負荷をかけて本番環境に必要なインスタンスタイプやECSタスクの個数、割り当てメモリ等を導きだす

- プロファイル

- ブランチ
  - Git Flow

- 環境変数の利用
  - ECSタスクの環境変数変更とをするだけで良い

### 本番環境
- ログ出力
  - コンテナがログをはく

  - Kinesis Data Firehose
    - エラーのみとメインのものを分ける
      - DokcerのEntrypintのjavaコマンドに追加        

- 監視
  - エラーログ監視
    - Zabbix agentがエラーログ監視
    - EC2インスタンス監視（CPU/メモリ割り当て）
    - ECS監視
      - Docker space監視(cronで確認)

  - 監視内容
    - ヘルスチェック
      - RDBBやキャッシュの疎通まで確認
    - アプリケーションメトリクス

### まとめ
- Webサーバと入り口のコンテナだけ1つのタスクに同居させ、他は別々のタスクにした
- Dockerコンテナ入れ替え時の待ち時間に注意